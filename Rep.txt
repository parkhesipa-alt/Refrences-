import pdfplumber
import re


class GSTPaymentParserDebug:

    TAX_STARTERS = ["Integrated", "Central", "State/UT", "Cess"]

    def __init__(self, pdf_path: str):
        self.pdf_path = pdf_path

    def parse(self):

        print("\n================ STEP 1: PAGE 2 TEXT ================\n")

        with pdfplumber.open(self.pdf_path) as pdf:
            if len(pdf.pages) < 2:
                raise ValueError("PDF does not contain Page 2.")
            page_text = pdf.pages[1].extract_text()

        print(page_text)

        print("\n================ STEP 2: EXTRACT 6.1 SECTION ================\n")

        match_6_1 = re.search(r"6\.1\s+Payment of tax(.*?)(6\.2|$)", page_text, re.DOTALL)
        if not match_6_1:
            raise ValueError("6.1 section not found")

        section_6_1 = match_6_1.group(1)
        print(section_6_1)

        print("\n================ STEP 3: EXTRACT SECTION (A) ================\n")

        match_a = re.search(r"\(A\).*?Other than reverse charge(.*?)\(B\)", section_6_1, re.DOTALL)
        if not match_a:
            raise ValueError("Section A not found")

        section_a = match_a.group(1)
        print(section_a)

        print("\n================ STEP 4: SPLIT LINES ================\n")

        lines = [line.strip() for line in section_a.split("\n") if line.strip()]

        for idx, line in enumerate(lines):
            print(f"{idx} -> {line}")

        print("\n================ STEP 5: ROW PARSING ================\n")

        result = {}

        for idx, line in enumerate(lines):

            words = line.split()

            if words and words[0] in self.TAX_STARTERS:

                tax_type = words[0]

                if tax_type != "Cess":
                    tax_type = tax_type + " tax"

                print(f"\n------ Detected Tax Row: {tax_type} ------")
                print("Raw Line:", line)

                numbers = re.findall(r'\d+\.\d+|\d+', line)
                print("Extracted Numbers:", numbers)

                if len(numbers) < 7:
                    print("⚠ Not enough numeric columns detected.")
                    continue

                # Column mapping
                tax_payable = float(numbers[0])
                adjustment = float(numbers[1])
                net_tax_payable = float(numbers[2])

                itc_integrated = float(numbers[3])
                itc_central = float(numbers[4])
                itc_state = float(numbers[5])
                itc_cess = float(numbers[6])

                print("\n--- Column Mapping ---")
                print("Tax Payable       :", tax_payable)
                print("Adjustment        :", adjustment)
                print("Net Tax Payable   :", net_tax_payable)
                print("ITC Integrated    :", itc_integrated)
                print("ITC Central       :", itc_central)
                print("ITC State/UT      :", itc_state)
                print("ITC Cess          :", itc_cess)

                primary_map = {
                    "Integrated tax": itc_integrated,
                    "Central tax": itc_central,
                    "State/UT tax": itc_state,
                    "Cess": itc_cess
                }

                primary_value = primary_map[tax_type]

                print("\n--- Decision Logic ---")

                if primary_value != 0:
                    print("Using PRIMARY column value:", primary_value)
                    result[tax_type] = primary_value
                else:
                    print("Primary is 0 → Checking fallback columns")
                    fallback_used = False

                    for val in [itc_integrated, itc_central, itc_state, itc_cess]:
                        if val != 0:
                            print("Using FALLBACK value:", val)
                            result[tax_type] = val
                            fallback_used = True
                            break

                    if not fallback_used:
                        print("All ITC columns are 0.")
                        result[tax_type] = 0.0

        print("\n================ FINAL RESULT ================\n")
        print(result)

        return result


# -----------------------------
# RUN
# -----------------------------
if __name__ == "__main__":
    pdf_file = r"yourfile.pdf"

    parser = GSTPaymentParserDebug(pdf_file)
    parser.parse()













import pdfplumber
import re


class GSTPaymentParserAuto:

    def __init__(self, pdf_path: str):
        self.pdf_path = pdf_path

    def parse(self):

        with pdfplumber.open(self.pdf_path) as pdf:
            page_text = pdf.pages[1].extract_text()

        # Extract 6.1
        section_6_1 = re.search(
            r"6\.1\s+Payment of tax(.*?)(6\.2|$)",
            page_text,
            re.DOTALL
        ).group(1)

        # Extract Section A
        section_a = re.search(
            r"\(A\).*?Other than reverse charge(.*?)\(B\)",
            section_6_1,
            re.DOTALL
        ).group(1)

        lines = [l.rstrip() for l in section_a.split("\n") if l.strip()]

        print("\n========== HEADER DETECTION ==========\n")

        # Find header line that contains ITC column names
        header_line = None
        for line in lines:
            if "Integrated" in line and "Central" in line and "State/UT" in line:
                header_line = line
                break

        if not header_line:
            raise ValueError("ITC header line not found")

        print("Header Line Found:")
        print(header_line)

        # Detect column start positions dynamically
        col_positions = {
            "Integrated": header_line.index("Integrated"),
            "Central": header_line.index("Central"),
            "State/UT": header_line.index("State/UT"),
            "Cess": header_line.index("Cess"),
        }

        print("\nDetected Column Positions:")
        for k, v in col_positions.items():
            print(f"{k}: starts at index {v}")

        print("\n========== ROW PARSING ==========\n")

        result = {}

        TAX_ROWS = ["Integrated", "Central", "State/UT", "Cess"]

        for line in lines:

            for tax in TAX_ROWS:

                if line.startswith(tax):

                    print("\nProcessing Row:", line)

                    # Slice values using column positions
                    itc_integrated_slice = line[col_positions["Integrated"]:col_positions["Central"]]
                    itc_central_slice = line[col_positions["Central"]:col_positions["State/UT"]]
                    itc_state_slice = line[col_positions["State/UT"]:col_positions["Cess"]]
                    itc_cess_slice = line[col_positions["Cess"]:]

                    # Extract numbers from slices
                    def extract_number(text):
                        match = re.search(r'\d+\.\d+|\d+', text)
                        return float(match.group()) if match else 0.0

                    itc_integrated = extract_number(itc_integrated_slice)
                    itc_central = extract_number(itc_central_slice)
                    itc_state = extract_number(itc_state_slice)
                    itc_cess = extract_number(itc_cess_slice)

                    print("ITC Integrated:", itc_integrated)
                    print("ITC Central   :", itc_central)
                    print("ITC State/UT  :", itc_state)
                    print("ITC Cess      :", itc_cess)

                    tax_label = tax if tax == "Cess" else tax + " tax"

                    primary_map = {
                        "Integrated tax": itc_integrated,
                        "Central tax": itc_central,
                        "State/UT tax": itc_state,
                        "Cess": itc_cess
                    }

                    primary_value = primary_map[tax_label]

                    if primary_value != 0:
                        print("Using PRIMARY:", primary_value)
                        result[tax_label] = primary_value
                    else:
                        print("Primary is 0 → Checking fallback")
                        for val in [itc_integrated, itc_central, itc_state, itc_cess]:
                            if val != 0:
                                print("Using FALLBACK:", val)
                                result[tax_label] = val
                                break
                        else:
                            result[tax_label] = 0.0

        print("\n========== FINAL RESULT ==========\n")
        print(result)

        return result


# Run
if __name__ == "__main__":
    pdf_file = r"yourfile.pdf"
    parser = GSTPaymentParserAuto(pdf_file)
    parser.parse()


