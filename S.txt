import asyncio
import re
import time
import logging
from fastapi import APIRouter, HTTPException

from app.models.bulk_models import BulkPANRequest
from app.services.pan_service import fetch_pan_details_async
from app.services.utils import generate_case_id

router = APIRouter()
logger = logging.getLogger(__name__)

PAN_REGEX = r"^[A-Z]{5}[0-9]{4}[A-Z]$"

# ==============================
# ðŸ”¥ GLOBAL PROTECTION (Perfios Safe)
# ==============================

MAX_CONCURRENT_CALLS = 2              # Perfios safe
RATE_LIMIT_PER_SEC = 2                # 2 requests per second
RATE_INTERVAL = 1 / RATE_LIMIT_PER_SEC

GLOBAL_SEMAPHORE = asyncio.Semaphore(MAX_CONCURRENT_CALLS)
RATE_LOCK = asyncio.Lock()
LAST_CALL_TIME = 0


async def rate_limited_call(pan: str, case_id: str):
    """
    Global rate limiter + concurrency control
    """

    global LAST_CALL_TIME

    async with GLOBAL_SEMAPHORE:

        async with RATE_LOCK:
            now = time.time()
            elapsed = now - LAST_CALL_TIME

            if elapsed < RATE_INTERVAL:
                await asyncio.sleep(RATE_INTERVAL - elapsed)

            LAST_CALL_TIME = time.time()

        try:
            return await asyncio.wait_for(
                fetch_pan_details_async(
                    pan=pan,
                    consent="Y",
                    lite="Y",
                    case_id=case_id
                ),
                timeout=15  # safety timeout
            )
        except asyncio.TimeoutError:
            logger.error(f"Timeout calling Perfios for PAN {pan}")
            return {"error": "Timeout"}


async def process_single_pan(pan: str):

    start_time = time.time()
    case_id = generate_case_id()

    if len(pan) != 10 or not re.match(PAN_REGEX, pan):
        return {
            "pan": pan,
            "name": None,
            "error": "Invalid PAN format"
        }

    attempt = 0
    response = None

    while attempt < 3:

        response = await rate_limited_call(pan, case_id)

        # Handle rate limit
        if isinstance(response, dict) and response.get("statusCode") == 429:
            backoff = 2 ** attempt
            logger.warning(f"429 received for {pan}. Retrying in {backoff}s")
            await asyncio.sleep(backoff)
            attempt += 1
            continue

        # Success
        if isinstance(response, dict) and "result" in response:
            duration = round(time.time() - start_time, 2)
            logger.info(f"PAN {pan} success in {duration}s")

            return {
                "pan": pan,
                "name": response["result"].get("name"),
                "caseId": case_id
            }

        attempt += 1
        await asyncio.sleep(1)

    logger.error(f"PAN {pan} failed after retries")

    return {
        "pan": pan,
        "name": None,
        "caseId": case_id,
        "error": "Failed after 3 attempts"
    }


@router.post("/bulk_pan")
async def bulk_pan_verification(req: BulkPANRequest):

    if not req.panList:
        raise HTTPException(status_code=400, detail="panList cannot be empty")

    if len(req.panList) > 50:
        raise HTTPException(status_code=400, detail="Max 50 PANs allowed per request")

    tasks = [process_single_pan(pan) for pan in req.panList]

    results = await asyncio.gather(*tasks)

    return {
        "total": len(results),
        "results": results
    }
