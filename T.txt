import os
from fastapi import FastAPI
from app.controllers.lrs_controller import router as lrs_router
from app.middleware.logging import LoggingMiddleware

SCRIPT_NAME = os.getenv("SCRIPT_NAME", "")

app = FastAPI(title="LRS Verification API")

# Logging middleware
app.add_middleware(LoggingMiddleware)

# Health MUST be without prefix
@app.get("/health")
async def health():
    return {"status": "UP"}

# APIs with optional prefix
if SCRIPT_NAME:
    app.include_router(lrs_router, prefix=SCRIPT_NAME)
else:
    app.include_router(lrs_router)













from fastapi import APIRouter, HTTPException
from typing import List
from app.models.lrs_model import LRSRequest
from app.services.lrs_service import fetch_lrs_data_async

router = APIRouter()

@router.post("/lrs_pan")
async def verify_single_pan(request: LRSRequest):
    """
    Single PAN verification (async)
    """
    try:
        result = await fetch_lrs_data_async(request.pan)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/lrs_pan/bulk")
async def verify_bulk_pan(requests: List[LRSRequest]):
    """
    BULK PAN verification (parallel)
    """
    try:
        tasks = [
            fetch_lrs_data_async(req.pan)
            for req in requests
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        response = []
        for pan_req, result in zip(requests, results):
            if isinstance(result, Exception):
                response.append({
                    "pan": pan_req.pan,
                    "error": str(result)
                })
            else:
                response.append({
                    "pan": pan_req.pan,
                    "result": result
                })

        return response

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))








from pydantic import BaseModel, Field, constr

class LRSRequest(BaseModel):
    pan: constr(
        min_length=10,
        max_length=10,
        pattern=r'^[A-Za-z]{5}\d{4}[A-Za-z]{1}$'
    ) = Field(..., description="PAN number (exactly 10 characters)")




















import base64
import json
import html
import asyncio
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Hash import SHA256
from app.services.fetch import get_secret_from_gcp
import httpx
import random
import string

IV_SIZE = 12
TAG_SIZE = 16

project_id = ""

client_id = get_secret_from_gcp("LRS_CLIENT_ID", project_id)
client_secret = get_secret_from_gcp("LRS_SECRET_ID", project_id)
rbi_public_cert = get_secret_from_gcp("LRS_CERT_KEY", project_id)

API_URL = "https://test"

def generate_unique_id(min_len=2, max_len=16):
    length = random.randint(min_len, max_len)
    chars = string.ascii_letters + string.digits
    return ''.join(random.choices(chars, k=length))

def aes_gcm_encrypt(plain_text: str, key: bytes) -> str:
    iv = get_random_bytes(IV_SIZE)
    cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
    ciphertext, tag = cipher.encrypt_and_digest(plain_text.encode())
    encrypted = iv + ciphertext + tag
    return base64.b64encode(encrypted).decode()

def aes_gcm_decrypt(enc_b64: str, key: bytes) -> str:
    decoded = base64.b64decode(enc_b64)
    iv = decoded[:IV_SIZE]
    ciphertext = decoded[IV_SIZE:-TAG_SIZE]
    tag = decoded[-TAG_SIZE:]
    cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
    decrypted = cipher.decrypt_and_verify(ciphertext, tag)
    return decrypted.decode()

async def fetch_lrs_data_async(pan: str):
    unique_id = generate_unique_id()

    aes_key = get_random_bytes(32)
    aes_key_b64 = base64.b64encode(aes_key).decode()

    encrypted_client_auth = aes_gcm_encrypt(
        f"{client_id}:{client_secret}", aes_key
    )

    data_body = [{
        "structureRefno": {"code": "LRSDATA", "version": 1, "agencyID": "RBI"},
        "obs": [{"pan": [pan]}]
    }]

    encrypted_body = aes_gcm_encrypt(json.dumps(data_body), aes_key)

    public_key = RSA.import_key(rbi_public_cert)
    cipher_rsa = PKCS1_OAEP.new(public_key, hashAlgo=SHA256)
    encrypted_key = cipher_rsa.encrypt(aes_key_b64.encode())
    encrypted_key_data = base64.b64encode(encrypted_key).decode()

    final_body = {
        "header": {
            "authInfo": {
                "LoginParams": ["CLIENT_AUTH_INFO", encrypted_client_auth],
                "UserType": "SYSTEM",
                "AuthenticationType": "API_AUTH",
                "Key_data": encrypted_key_data
            }
        },
        "body": {
            "lrs_body": encrypted_body,
            "uniqueId": unique_id
        }
    }

    headers = {
        "Content-Type": "application/json",
        "Client-Id": client_id,
        "channelkey": "key10",
        "datatype": "application/json"
    }

    async with httpx.AsyncClient(timeout=30) as client:
        response = await client.post(
            API_URL,
            headers=headers,
            json=final_body,
            verify=False
        )

    decoded = html.unescape(response.text)
    data = json.loads(decoded)

    if isinstance(data.get("body"), str):
        data["body"] = json.loads(data["body"])

    encrypted_lrs = data.get("body", {}).get("lrsOutput", {}).get("lrsResponse")

    if not encrypted_lrs:
        raise Exception("lrsResponse not found")

    decrypted = aes_gcm_decrypt(encrypted_lrs, aes_key)
    return json.loads(decrypted)








import time
from fastapi import Request

class LoggingMiddleware:
    async def __call__(self, request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        process_time = round(time.time() - start_time, 4)

        print({
            "method": request.method,
            "path": request.url.path,
            "status_code": response.status_code,
            "process_time_sec": process_time
        })

        return response


